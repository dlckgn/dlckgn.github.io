---
title: "시간복잡도"
excerpt: "시간복잡도에 대한 이해"

categories:
 - Study
tags:
 - Study
last_modified_at: 2021-03-31T12:30:00-15:00
---
# 20210131(일)
## 1. 학습날짜
20210131(일)
## 2. 학습시간
14:00 ~ 18:00(카페), 19:00 ~ 20:00(카페)
## 3. 학습 범위 및 주제
시간복잡도
## 4. 동료학습
해당사항 없음
## 5. 학습목표
시간복잡도의 이해
## 6. 상세 학습 내용
### 6.1. 복잡도 분석(Complexity Analysis)
어떤 문제를 푸는데 다양한 알고리즘이 존재한다. 이 중 어떤 알고리즘이 더 좋은지를 분석하기 위해서 복잡도를 정의하고 계산한다. 알고리즘 복잡도의 계산 항목은 2가지 있다.
1. 시간 복잡도: 알고리즘에 사용되는 연산횟수의 총량
2. 공간 복잡도: 알고리즘에 사용되는 메모리 공간의 총량


공간 복잡도의 경우 최근 컴퓨터 성능의 발달로 인해 메모리의 여유 공간이 충분하다 못해 넘치기에 공간 복잡도의 중요성은 많이 낮아졌다. 반면, 시간 복잡도의 경우 알고리즘을 잘못 구성하였을 경우 결과값이 나오지 않거나 현저하게 느린속도가 나오기에 최근에는 공간복잡도 보다는 시간복잡도를 우선시하여 프로그램을 작성한다.
### 6.2. 시간복잡도
시간 복잡도의 경우 '연산의 횟수'를 센다. 어떤 함수를 돌렸을 때 결과를 반환할 때까지 걸리는 '실행시간'이 아니다. 만약 실행시간으로 시간복잡도를 계산할 경우 아래와 같은 단점이 있기 때문이다.

```
1. 측정을 위한 완성된 프로그램이 필요하다.
2. 모든 플랫폼에서 동일한 결과를 산출하지 못한다.
```
그렇기에 시간복잡도는 '연산의 횟수'이다. 즉, 시간복잡도의 단위는 시간이 아닌 시행 횟수 인 것이다. 연산횟수를 바탕으로 시간복잡도를 산출할 경우의 이점은

```
1. 실행이 필요하지 않다.
2. h/w, s/w가 필요하지 않다.(수도코드로 충분히 계산가능하다.)
3. 모든 플랫폼에서 동일한 결과를 산출한다.
```
연산 횟수를 카운팅 할 때 3가지 경우가 있다.

```
1. 최선의 경우: 오메가 표기법
2. 평균의 경우: 세타 표기법
3. 최악의 경우: 빅오 표기법
```
평균인 세타 표기를 하면 가장 정확하고 좋겠지만 평가하기가 까다롭다. 따라서 최악의 경우인 빅오를 사용한다.
### 6.3. 시간복잡도에 나타는 수들
![시간 복잡도 참고할 수](https://user-images.githubusercontent.com/67093720/106386117-ce695600-6416-11eb-816f-d8852dd300e3.gif)

### 6.4. 빅오 표기법(Big-O)
빅오 표기법은 불필요한 연산을 제거하여 알고리즘분석을 쉽게 할 목적으로 사용된다.
빅오 표기법은 다음과 같은 특징을 갖는다.
1. **상수항 무시**: 빅오 표기법은 데이터 입력값이 충분히 크다고 가정하고 있고, 알고리즘의 효율성 또한 데이터 입력값의 크기에 따라 영향 받기 때문에 상수항 같은 사소한 부분은 무시한다. 예를들어 `O(2N) -> O(N)`과 같이 상수항은 무시하고 표기한다.
2. **영향력 없는 항 무시**: 빅오 표기법은 데이터 입력값의 크기에 따라 영향을 받기 때문에 가장 영향력이 큰 항에 이외에 영향력이 없는 항들은 무시한다. 예를들어 `O(N^2+2N+1) -> O(N^2)와 같이 영향력이 지배적인 `N^2`이외에 영향력이 없는 항들은 무시한다.

#### 빅오 표기법 성능비교
![Comparing Big O Functions](https://user-images.githubusercontent.com/67093720/106386206-3a4bbe80-6417-11eb-8322-65da6723f9d6.png)

빅오 표기법의 예제로는 다음과 같은 것들이 있다.

```
1. O(1): Stack에서 Push, Pop
2. O(log n): 이진트리
3. O(n): for 문
4. O(nlog n): 퀵 정렬(quick sort), 병합정렬(merge sort), 힙 정렬(heap sort)
5. O(n^2): 이중 for문, 삽입정렬(insertion sort), 거품정렬(bubble sort), 선택정렬(selection sort)
6. O(2^n): 피보나치 수열
```
### 6.5. 시간복잡도 계산하기
프로그램의 진행 정도를 나타내는 기본 단위인 Elementary Operation이 일어나는 수를 측정한다. Elementary Operation은 다음과 같은 것들을 말한다.

```
1. 대입연산
2. 덧셈, 뺄셈, 곱셈, 나눗셈
3. 비교구문
4. 함수호출
```
다음과 방법들로 이를 카운팅한다.

```
1. 전역변수를 이용하여 Elementray Operation을 카운팅한다.
2. 각 실행문 별로 Step수와 실행 횟수를 분석한다.
```
#### 6.5.1. 전역변수를 이용하여 카운팅

```
let count = 0;
function sum(list, n) {
    let tempSum = 0; // 대입연산
    count++;

    for (let i = 0; i < n; i++) {
        count++; // loop 한번 돌 때 마다
        tempSum += list[i];
        count++; // 대입연산
    }
    count++; // for loop 끝날 때 한번
    count++; // return 수행
    return tempSum;
}
```

#### 6.5.2. 각 실행문 별로 Step수로 실행 횟수 분석
<img width="516" alt="실행 횟수 분석" src="https://user-images.githubusercontent.com/67093720/106386679-80098680-6419-11eb-8a59-e0975b3289f4.png">

### 6.6. 정렬 알고리즘, 자료구조 비교
#### 6.6.1. 정렬 알고리즘 비교
<img width="621" alt="정렬 알고리즘 비교" src="https://user-images.githubusercontent.com/67093720/106386809-19d13380-641a-11eb-9f64-66b67d66f8e6.png">

#### 6.6.2. 자료구조 비교
<img width="557" alt="자료구조 비교" src="https://user-images.githubusercontent.com/67093720/106386810-1b026080-641a-11eb-92e5-674d0c83885e.png">


## 7. 학습 내용에 대한 개인적인 총평
오늘은 공부하고자 생각하고 있었던 시간복잡도에 대해서 공부하였다. 이제 나는 알고리즘과 자료구조에 대해서 더 공부하게 될 것이라고 생각하였고, 이에 대해서 제대로 이해하기 위해서는 시간복잡도를 먼저 제대로 이해해야한다고 생각했기 때문이다. 오늘 막상 시간복잡도를 공부해보니 깊게 공부할 경우에는 더욱 깊게 공부할 내용이라는 것을 알게 되었다. 하지만 우선은 내가 프로그래밍을 공부하는데 정말 필요할 것 같은 중요하게 도움이 될 것 같은 부분들을 위주로 공부하였다. 나중에 좀 더 깊숙하고 자세한 이해를 위한 공부가 필요할 것 같다. 또한, 아쉬운 점은 시간복잡도만을 다루기에 시간복잡도만 공부하면 될 것이라고 생각하였는데, 생각보다 공간복잡도 또한 중요하게 여겨지는 것 같다. 나중에 더 깊숙하게 공부할 때에는 메모리에 대한 구조를 제대로 이해하고 공간복잡도 또한 제대로 다뤄봐야 겠다고 생각했다. 우선 오늘의 공부를 통해서 시간복잡도에 대한 이해를 어느정도는 제대로 한 것 같다고 생각한다. 당장 내가 활용할 수 있는 시간복잡도를 구하는 방법도 익히었고, 어떤 자료구조가 어떠한 장단점이 있는지 이를 공부함으로 한 눈에 알게 될 수 있었다. 이로써, 이번 주에 공부하였던 배열과 연결리스트의 장단점에 대한 이해에도 도움이 되었다. 다음 주에는 최대한 libft를 끝내는 것을 목표로 해서 공부를 진행해야겠다.
## 8. 다음 학습 계획

* libft bonus 함수 구현하기
* 메모리 구조 다시 이해하기
* 다른 자료구조들 구현해보기
* Pocu C 강의 듣기
* 마크다운 문법을 제대로 사용하여 보고서 작성하기

## 9. 참고

* [시간의 복잡도 총정리(알고리즘)](https://skmagic.tistory.com/164)
* [알고리즘의 시간 복잡도와 Big-O 쉽게 이해하기](https://blog.chulgil.me/algorithm/2)
* [알고리즘과 시간 복잡도](https://feel5ny.github.io/2017/12/09/CS_01/)
* [Time Complexity & Data Structure 시간복잡도와 자료구조](https://medium.com/amhocode/time-complexity-data-structure-시간복잡도와-자료구조-5188296f2764)
* [[자료구조] 시간 복잡도와 공간 복잡도](https://m.blog.naver.com/demonic3540/221229805234)
* [빅오 표기법 (big-O notation) 이란](https://noahlogs.tistory.com/27)

