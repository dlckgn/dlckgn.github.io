# 20210130(토)
## 1. 학습날짜
20210130(토)  
## 2. 학습시간
13:00 ~ 18:00(카페)
## 3. 학습 범위 및 주제
연결리스트 함수의 매개변수로 이중포인터를 쓰는 이유, libft bonus 파트(ft_lstadd_front, ft_lstsize, ft_lstlast, ft_lstadd_back)
## 4. 동료학습
해당사항 없음  
## 5. 학습목표
libft bonus 파트의 함수들을 이해하고 이를 구현한다.
## 6. 상세 학습 내용
### 6.1. 연결 리스트 함수의 매개변수로 이중포인터를 쓰는 이유
이중 포인터를 사용함으로 head노드가 참조하는 값을 변경하기 위함이다. 단일 포인터를 사용하게 되면 head노드가 참조하는 값만을 복사해오고 복사해온 함수 내의 지역변수의 값을 바꾸기 때문에 함수가 끝나면 지역변수는 사라지고, 실질적으로는 head노드가 참조하고 있는 값을 바꿀 순 없다. 따라서 이중 포인터를 사용하고 head노드가 참조하고 있는 값의 주소를 매개변수로 받음으로써, 해당 함수의 지역변수를 \* 통해 참조하여(해당 주소를 참조하여) 값을 변경함에 따라 head노드가 참조하고 있는 값까지 변경되기에 연결 리스트 함수의 매개변수로 단일 포인터가 아닌 이중 포인터를 사용한다.  
### 6.2. ft_lstadd_front
##### 6.2.1. 프토로타입
ft_lstadd_front 함수의 프로토타입은 다음과 같다.
`void ft_lstadd_front(t_list **list, t_list *new);`
##### 6.2.2. 매개변수&반환값
###### 매개변수
1. 첫 번째 링크 리스트의 포인터 주소
2. 리스트에 추가되기 위한 요소의 포인터 주소.

###### 반환값
없음
##### 6.2.3. 사용가능 함수
없음
##### 6.2.4. 함수의 기능
새 요소 'new'를 리스트의 시작부분에 추가한다. 이에 따라 새 노드의 다음 주소를 head노드가 가르키고 있던 것으로 설정하고, head노드가 참조하는 값을 새 노드로 설정한다.
##### 6.2.5. 코드

```c
#include "libft.h"
void    ft_lstadd_front(t_list **lst, t_list *new)
{
    if (lst == NULL || new == NULL)
        return ;
    new->next = *lst;
    *lst = new;
}
```
##### 6.2.6. 코멘트
이 함수는 사실 구현하려는 내용보다는 매개변수로 단일 포인터가 아닌 이중 포인터를 사용하는 이유를 이해하는 것이 더 어려웠다. 이에 대한 내용을 6.1에서 다루었다. 또한, 연결 리스트 자료구조를 사용할 때 이러한 추가 함수를 많이 만들어 사용하는데, 다른 구현된 함수들을 참고해보았을 때 이 함수보다 좀 더 기능이 좋고 활용도가 높은 함수로 만들 수 있을 것 같은데 이러한 함수를 구현하라고 요구하는 것에 의문이 들었다. 그 다음 함수들을 구현하면서 굳이 이렇게 세분화 해놓은 함수를 구현하라는 이유를 이해할 수 있으면 좋겠다.
### 6.3. ft_lstsize
##### 6.3.1. 프토로타입
ft_lstsize 함수의 프로토타입은 다음과 같다.
`int ft_lstsize(t_list *lst);`
##### 6.3.2. 매개변수&반환값
###### 매개변수
1. 리스트의 시작

###### 반환값
리스트의 길이
##### 6.3.3. 사용가능 함수
없음
##### 6.3.4. 함수의 기능
리스트의 요소의 갯수를 센다. 
##### 6.3.5. 코드

```c
#include "libft.h"
int ft_lstsize(t_list *lst)
{
    int size;

    size = 0;
    while (lst != NULL)
    {
        lst = lst->next;
        size++;
    }
    return (size);
}
```
##### 6.3.6. 코멘트
리스트의 요소의 갯수를 세는 함수이다. 처음에 head 노드는 리스트의 첫 번째 요소를 가리키고 있다. 이에 따라 head 노드의 next 변수를 참조함에 따라 head 노드가 첫 번째 요소의 노드로 바뀌게 된다. 이런식으로 마지막 요소에 까지 진행되게 되고 마지막 요소의 next 변수를 참조하면 NULL이기에 반복문을 빠져나오게 된다. 결국 리스트의 모든 요소를 첫 요소 부터 마지막 요소까지 갯수를 셀 수 있게 된다.
### 6.4. ft_lstlast
##### 6.4.1. 프토로타입
ft_lstlast 함수의 프로토타입은 다음과 같다.
`t_list *ft_lstlast(t_list *lst);`
##### 6.4.2. 매개변수&반환값
###### 매개변수
1. 리스트의 시작

###### 반환값
리스트의 마지막 요소
##### 6.4.3. 사용가능 함수
없음
##### 6.4.4. 함수의 기능
리스트의 마지막 요소를 반환한다.
##### 6.4.5. 코드

```c
#include "libft.h"
t_list  *ft_lstlast(t_list *lst)
{
    while (lst->next != NULL)
        lst = lst->next;
    return (lst);
}
```
##### 6.4.6. 코멘트
리스트의 마지막 요소를 반환하는 함수이다. 반복문을 첫 요소를 가르키는 head 노드부터 마지막 요소까지 넘어가기 위해 다음 요소의 주소를 가르키는 next 변수가 NULL이 아닐 때 까지 다음 요소로 넘어가는 것을 반복한다. 그리고 next 변수가 NULL일 때가 마지막 요소이기에 이를 반환한다.
### 6.5. ft_lstadd_back
##### 6.5.1. 프토로타입
ft_lstadd_back 함수의 프로토타입은 다음과 같다.
`void ft_lstadd_back(t_list **lst, t_list *new);`
##### 6.5.2. 매개변수&반환값
###### 매개변수
1. 첫 번째 링크 리스트의 포인터 주소.
2. 리스트에 추가되기 위한 요소의 포인터 주소.

###### 반환값
없음
##### 6.5.3. 사용가능 함수
없음
##### 6.5.4. 함수의 기능
새 요소 'new'를 리스트의 끝부분에 추가한다. 이에 따라 새 노드의 다음 주소를 마지막 노드가 가르키고 있던 것으로 설정하고, 마지막 노드의 다음 주소를 새 노드로 한다.
##### 6.5.5. 코드

```c
#include "libft.h"
void    ft_lstadd_back(t_list **lst, t_list *new)
{
    t_list  *last;

    if (lst == NULL || new_node == NULL)
        return ;
    if (*lst == NULL)
    {
        *lst = new_node;
        return ;
    }
    last = ft_lstlast(*lst);
    new->next = last->next;
    last->next = new;
}
```
##### 6.5.6. 코멘트
새로 만들어진 new 노드를 리스트의 마지막 부분에 추가하는 함수이다. 앞서 만들었던 첫 부분에 요소를 추가하는 함수와 비슷하다. 앞서 만들었던 ft_lstlast(); 함수를 활용하여 마지막 요소를 구한다. 그리고 마지막 요소가 가르키고 있던 것(=NULL)을 새 노드 new의 다음 주소로 설정한다. 그리고 마지막 요소는 다음 주소로 새 노드 new를 가르키도록 한다. 여기서 예외처리를 해준 부분에 대해서 살펴보면, `*lst == NULL`은 head 노드가 가르키는 첫 번째 요소의 주소가 비었다는 것임으로 해당 리스트는 빈 리스트라는 뜻이다. 또한, `lst == NULL`은 head 노드가 존재하지 않음으로 리스트 자체가 존재하지 않음을 의미한다.
## 7. 학습 내용에 대한 개인적인 총평
오늘은 저번에 연결리스트를 공부하고 libft bonus 파트의 함수들을 구현하던 중 매개변수로 이중포인터를 사용하는 것에 대한 이해를 하기 위해 공부하고, 나머지 함수들을 추가적으로 구현하였다. 먼저 이중포인터를 사용하는 것에 대한 이해를 위해 다양한 자료들을 참고하였다. 이러한 자료들을 참고할 때 복잡한 내용이다 보니 그림을 통해서 설명해주는 자료가 많았는데, 그림을 통해 이해하는 것이 포인터를 사용하는 부분에 대한 이해를 돕는데 크게 도움을 준다고 느꼈다. 그래서 나도 포인터로 함수의 구조를 짜거나 코드를 구성할 때 그림을 그려가며 구상하는 습관을 길러보아야 겠다고 생각하였다. 그리고 이 내용들을 이해 할 때 메모리 구조에 대한 내용이 또 나왔다. 한번 공부해서 익혀놓은 내용이었지만, 막상 다시 접하니 헷갈리는 내용이 많았다. 다시금 한번 더 공부해야겠다고 생각했다. 또한, 그렇게 다양한 자료들을 참고하여 공부하다보니 자료구조를 구현하고 이 자료구조들을 사용하기 위한 함수들을 구현해놓은 것이 연결리스트 말고도 많다는 것을 알게 되었다. 나중에 이러한 자료구조들도 전부 구현해본다면 정말 크게 도움이 될 것 같다고 생각하였다. 오늘 추가적으로 구현하였던 libft bonus 파트의 함수들을 연결리스트의 개념을 이해하니 생각보다 수월하게 구현되었다. 하지만 이 함수들을 구현할 때 예외처리와 같은 부분들은 좀 더 고민하고 신경써봐야할 부분이라고 생각이 들었다.
## 8. 다음 학습 계획

* 시간 복잡도 공부하기(자료구조에 따른 시간 복잡도)
* libft bonus 함수 구현하기
* 메모리 구조 다시 이해하기
* 다른 자료구조들 구현해보기
* Pocu C 강의 듣기
* 마크다운 문법을 제대로 사용하여 보고서 작성하기

## 9. 참고

* [리스트 구현시 이중포인터를 사용하는 이유.](http://blog.naver.com/PostView.nhn?blogId=dunlod&logNo=220844585669&parentCategoryNo=&categoryNo=86&viewDate=&isShowPopularPosts=true&from=search)
* [링크드 리스트](https://rooov.tistory.com/22)
* [LinkedList 연결리스트 이중포인터 해드포인터 깔끔한 정리](https://csm931008.tistory.com/16)
* [Computer Engineering Programming 1](http://dslab.konkuk.ac.kr/Class/2008/08CEP1/Lecture%20Note/Lesson14.pdf) // Lesson 14
* [42Seoul Wiki](https://wiki.42seoul.work/ko/subjects/libft)
